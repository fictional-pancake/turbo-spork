2/5/16:
	This week I studied what we can do with Heroku, and
	whether it's going to be suitable for our project.
	So far, it appears that it will work, since it has
	support for plenty of technologies, including
	Node.js, websockets, and PostgreSQL, which we'll
	probably be using.  I wrote a rough protocol
	specification outlining generally what we're going
	to do for client-server-communication.  I also put
	together the initial server implementation, with a
	very bare-bones web server and a slightly more
	useful WebSocket server.  It's no game yet, but
	we're getting there.  As far as I can tell, Heroku
	only works with HTTP traffic, which is why the
	server is using WebSockets instead of normal
	sockets.  It's likely that we'll need a web server
	anyway though, so I think it's a good idea.  I also
	set up a PostgreSQL server on Heroku and my laptop.
	I studied db-migrate and it looks quite useful.

2/13/16:
	This week I started working with db-migrate and
	used it to set up the users table in the database.
	I also briefly studied password hashing methods and
	(probably prematurely) settled on bcrypt.  Not that
	we store any sensitive data at all, but prevention
	is simple and good practice.  I found
	bcrypt-nodejs, which should simplify trying to use
	it.  It seems to store the salt as part of the
	hash, so we don't need a separate column for that.
	In other news, I did a little more work on the game
	server, laying foundations to make it easier to
	handle messages from the client, and using that to
	allow users to join game rooms, though they're not
	actually useful yet, currently they only notify
	other users of your presence.  I also tried to
	detect disconnections and remove those players
	from their rooms.  I think it's working, but
	that's what testing is for!

2/21/16:
	This week (I start these with that phrase every
	time...) I worked more on the socket server, making
	it possible to start a game, though all that means
	right now is generating a few nodes with random
	positions and sending them to the clients.  We
	decided to make the battlefield have width and
	height of 100 internally for simplicity, and we'll
	scale it up to the screen size in the client once
	that actually exists.  I also changed the initial
	authentication message to actually do logins from
	the database.  Hopefully soon we'll figure out how
	the game mechanics are going to work well enough to
	implement them.  I'm not sure how much to leave to
	the clients and how much to handle server-side,
	since there are advantages to both, and both will
	have to do some computation.  We learned that the
	database is probably not scrublord, and can do
	queries.

2/28/16:
	Not much to say for this week.  Not much really
	happened, but we did get more visible work done
	than usual.  The signup page works now!  Probably.
	Last week, the progress was limited to having a
	page and checking whether the user "post.username"
	exists because Tony did it wrong.  Now, we check
	that their chosen username doesn't already exist
	and that it doesn't contain a colon, because we
	use that as a delimeter in the auth message, then
	adds the user to the database.  Perhaps we should
	ban other characters, but we haven't yet had a
	good argument either way.  Initially, the database
	had an id column, but we didn't really need it, so
	I added a migration to delete the table and
	recreate it because db-migrate is annoying about
	messing with the primary key.  We had an issue with
	a race condition causing the post data to never be
	recieved occasionally.  Hopefully it's fixed now.

3/4/16:
	The game client exists now!  It doesn't do much,
	but it's something.  It currently just displays a
	dialog that can accept credentials and connect to
	the server.  I used Java-WebSocket to handle
	connecting to the WebSocket server, as it appears
	to be almost the only library that attempts to do
	it.  It's a bit different than using WebSockets in
	JavaScript in several ways.  It requires
	subclassing the WebSocketClient class to use it,
	instead of the JavaScript approach using event
	handlers bound to the object.  It also doesn't
	actually do the connection until you call a method.
	The subclass idea was a bit of a problem for the
	way I was planning on making the client.  My plan
	was similar to the way I did the server, using an
	event handler to handle the initial auth message,
	then changing the handler to the main one.
	Unfortunately, that's not really possible with the
	subclass approach, so I made the subclass have a
	listener for the first message.  It's a bit weird,
	but it should work well.

3/30/16:
	It almost looks like a game now!  The client now
	has a more useful window than just "Welcome to the
	absence of a game", allowing joining rooms, seeing
	the other players in the room, starting the game,
	seeing the nodes, and winning by having everyone
	else leave.  The node info is provided by the
	server in JSON format, so I'm using JSON.simple to
	parse that from Java.  I had an odd issue with
	scaling where it jumped in scale instead of being
	smooth, but it turned out to be just an issue with
	using integer division where it shouldn't be.  The
	server has been improved slightly as well to make
	it easier to write the client and fix some other
	issues.  It now informs the client of leaving a
	room, sends a message when they win, and shouldn't
	crash when you create a user.  It also no longer
	allows you to start a game without another player
	in the room.

4/9/16:
	The game works!  You can play!  You can now send
	units, see units, and destroy units.  You can
	capture nodes and win.  I found lots of issues
	with the server code that I hadn't noticed before
	because they didn't matter, including placing
	nodes horribly, never destroying unit groups, and
	some others I forgot about.  I also wrote a few
	unit tests because that's always nice.  It also
	means we get a nice "build passing" badge in our
	README from Travis CI.  Eventually we might get
	it to automatically deploy when we make a new
	release.  Eventually we'll need to change the
	connection handshake to ensure protocol versions
	match, but I haven't done that yet.  For testing,
	I wrote a small script to connect to the server
	and join a room so I can start a game without
	running the whole client twice, since my computer
	is really bad at that.
